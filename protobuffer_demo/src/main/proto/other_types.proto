syntax = "proto3";


//import "school.proto"; //protobuffer_demo/src/main/proto/
import "google/protobuf/any.proto";


//The .proto file starts with a package declaration, which helps to prevent naming conflicts between different projects.
//Even if you do provide a java_package, you should still define a normal package as well to avoid name collisions in the Protocol Buffers
package myCompundNS;

/*In Java, the package name is used as the Java package unless you have explicitly specified a java_package
If you don’t specify this explicitly, it simply matches the package name given by the package declaration,
but these names usually aren’t appropriate Java package names (since they usually don’t start with a domain name).
*/
option java_package = "net.sahet.protobuf.sample.messages";


//The java_outer_classname option defines the class name of the wrapper class which will represent this file.
//If you don’t give a java_outer_classname explicitly, it will be generated by converting the file name to upper camel case.
//For example, “my_proto.proto” would, by default, use “MyProto” as the wrapper class name.
option java_outer_classname = "MyCompoundObject";


/**
The java_multiple_files = true option enables generating a separate .java file for each generated class
(instead of the legacy behavior of generating a single .java file for the wrapper class, using the wrapper class as an outer class, and nesting all the other classes inside the wrapper class).
 */
option java_multiple_files = true;


/*
Message definitions. A message is just an aggregate containing a set of typed fields.
Many standard simple data types are available as field types, including bool, int32, float, double, and string.
You can even define message types nested inside other messages
 */
message Person {
	/*
	The " = 1", " = 2" markers on each element identify the unique “tag” that field uses in the binary encoding.
	Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to
	use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used
	optional elements. Each element in a repeated field requires re-encoding the tag number,
	so repeated fields are particularly good candidates for this optimization.

	You must give each field in your message definition a number
	between 1 and 536,870,911 with the following restrictions:
	 */
		string name = 1;
		int32 id = 2;
		string email = 3;
		bool male = 4;

		enum TitleType {
			BC = 0;
			MG = 1;
			PhD = 2;
		}

		message Title {
			/**
			Use PascalCase (with an initial capital) for message names – for example, SongServerRequest.
			Use lower_snake_case for field names (including one of field and extension names) – for example, song_name.

			will be    java.lang.String getTitleName();
			*/
			string title_name = 1;
			TitleType type =  2;
	}

		repeated Title titles = 5;
}

message Animal {
		string name = 1;

		repeated AnimalType type = 3;

		enum AnimalType {
			CAT = 0;
			DOG = 1;
			FISH = 2;
			TORTOISE_TURTLE = 3;
			RABBIT = 4;
		}

		enum FileType {
			PROGID = 0;
			TERMID = 1;
			TRANID = 2;
		}

}

message Audience {
		repeated  Person people = 1;
		repeated Animal animals = 2;
}

message MyErrorStatus {
	string message = 1;
	/*
	The Any message type lets you use messages as embedded types without having their .proto definition.
	An Any contains an arbitrary serialized message as bytes,
	along with a URL that acts as a globally unique identifier for and resolves to that message’s type.

	The default type URL for a given message type is type.googleapis.com/_packagename_._messagename_
	 */
	repeated google.protobuf.Any details = 2;

	/*
	Map fields cannot be repeated
	https://protobuf.dev/programming-guides/proto3/#maps
	 */
	map<int32, string> errorsDetailsById = 3;

	//alternative map, if protobuf not support map
	repeated MapFieldEntry errorsDetailsById2 = 4;


	bytes bytesData = 5;

	repeated bytes bytesList = 6;
}

/*
The map syntax is equivalent to the following on the wire, so protocol buffers
implementations that do not support maps can still handle your data:
 */
message MapFieldEntry {
	int32 key = 1;
	string value = 2;
}







/**
Both messages and builders have auto-generated accessor methods for each field of the message;
messages have only getters while builders have both getters and setters.

As you can see, there are simple JavaBeans-style getters and setters for each field.

There are also has getters for each singular field which return true if that field has been set.


Notice how these accessor methods use camel-case naming, even though the .proto file uses lowercase-with-underscores.

This transformation is done automatically by the protocol buffer compiler so that the generated classes match standard Java style conventions.

You should always use lowercase-with-underscores for field names in your .proto files; this ensures good naming practice in all the generated languages

 */
